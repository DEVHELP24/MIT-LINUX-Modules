#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <sys/stat.h>
#include <unistd.h>

using namespace std;

// Function prototypes
void usage();
vector<string> getKernelModules();
string checkModuleErrors();
void saveResults(const string& outputDir, const string& outputFile, const string& content);
string generateOutputFilename(bool listModules, bool checkErrors, bool checkSystemdErrors, bool checkXorgDebug);

// Usage function
void usage() {
    cerr << "Usage: debugview-ng [-h] [-m] [-e] [-s] [-x] [-o output_directory]" << endl;
    cerr << "  -h: Display this help message" << endl;
    cerr << "  -m: List loaded kernel modules" << endl;
    cerr << "  -e: Check for errors related to kernel modules" << endl;
    cerr << "  -s: Find errors related to systemd services during startup" << endl;
    cerr << "  -x: Find errors and warnings in Xorg logs" << endl;
    cerr << "  -o output_directory: Specify the output directory to save results" << endl;
    exit(1);
}

// Function to get loaded kernel modules
vector<string> getKernelModules() {
    vector<string> modules;
    FILE* pipe = popen("lsmod", "r");
    if (!pipe) {
        cerr << "Failed to run command: lsmod" << endl;
        return modules;
    }

    char buffer[128];
    while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
        modules.push_back(string(buffer));
    }
    pclose(pipe);
    return modules;
}

// Enhanced function to check for kernel module errors and warnings
string checkModuleErrors() {
    string result = "Checking for errors related to kernel modules:\n";
    // Check dmesg for module-related errors or warnings
    result += "Checking dmesg for module errors or warnings:\n";
    
    // Execute command and capture output
    FILE* pipe = popen("dmesg | grep -iE '(modprobe|insmod|rmmod|module.*(failed|not found|error|denied|unknown symbol|unresolved symbol|init failed))'", "r");
    if (!pipe) {
        cerr << "Failed to run command: dmesg" << endl;
        return result;
    }

    char buffer[128];
    while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
        result += string(buffer);
    }
    pclose(pipe);

    // Similar checks for journalctl and logs can be added here...

    return result;
}

// Function to save results to output directory
void saveResults(const string& outputDir, const string& outputFile, const string& content) {
    string fullPath = outputDir + "/" + outputFile;
    ofstream outFile(fullPath);
    if (!outFile) {
        cerr << "Failed to open file for writing: " << fullPath << endl;
        return;
    }
    outFile << content;
    outFile.close();
}

// Generate output filename based on selected options
string generateOutputFilename(bool listModules, bool checkErrors, bool checkSystemdErrors, bool checkXorgDebug) {
    string filename = "ng_global_debug_results_" + to_string(time(nullptr));

    if (listModules) filename += "_modules";
    if (checkErrors) filename += "_errors";
    if (checkSystemdErrors) filename += "_systemd_errors";
    if (checkXorgDebug) filename += "_xorg_debug";

    return filename + ".txt";
}

// Main function
int main(int argc, char* argv[]) {
    bool listModules = false, checkErrors = false, checkSystemdErrors = false, checkXorgDebug = false;
    string outputDirectory;

    // Parse command-line options
    int opt;
    while ((opt = getopt(argc, argv, "hmesxo:")) != -1) {
        switch (opt) {
            case 'h':
                usage();
                break;
            case 'm':
                listModules = true;
                break;
            case 'e':
                checkErrors = true;
                break;
            case 's':
                checkSystemdErrors = true;
                break;
            case 'x':
                checkXorgDebug = true;
                break;
            case 'o':
                outputDirectory = optarg;
                break;
            default:
                usage();
        }
    }

    // Main script logic
    string result;
    if (!listModules && !checkErrors && !checkSystemdErrors && !checkXorgDebug) {
        cerr << "Error: No option selected. Please use at least one of the available options." << endl;
        usage();
    }

    // List loaded kernel modules (-m option)
    if (listModules) {
        result += "Loaded kernel modules:\n";
        auto modules = getKernelModules();
        for (const auto& mod : modules) {
            result += mod;
        }
        result += "\n";
    }

    // Check kernel module errors (-e option)
    if (checkErrors) {
        result += checkModuleErrors();
        result += "\n";
    }

    // Find errors related to systemd services during startup (-s option)
    if (checkSystemdErrors) {
        result += "Finding errors related to systemd services during startup:\n";
        FILE* pipe = popen("systemctl list-units --state=failed --type=service --no-legend", "r");
        char buffer[128];
        while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
            result += string(buffer);
        }
        pclose(pipe);
        result += (result.empty() ? "No failed systemd services found during startup.\n" : "\n");
    }

    // Find errors and warnings in Xorg logs (-x option)
    if (checkXorgDebug) {
        result += "Finding errors and warnings in Xorg logs:\n";
        FILE* pipe = popen("grep -iE '^\\[.*\\] \\(EE\\)|^\\[.*\\] \\(WW\\)' /var/log/Xorg.0.log", "r");
        char buffer[128];
        while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
            result += string(buffer);
        }
        pclose(pipe);
        result += "\n";
    }

    // Save results to the output directory if specified (-o option)
    if (!outputDirectory.empty()) {
        string outputFilename = generateOutputFilename(listModules, checkErrors, checkSystemdErrors, checkXorgDebug);
        saveResults(outputDirectory, outputFilename, result);
    } else {
        // Display results if not saved
        cout << result;
    }

    return 0;
}
